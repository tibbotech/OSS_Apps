include "global.tbh"

const CELL__SIMCARD_PIN = CELL__QUESTMARK	'<-- CHANGE THIS AS NEEDED
const FAIL_CONN_COUNT_MAX = 3

dim reprovision_needed as no_yes = NO
dim azure_fail_to_connect_count as byte = 0
dim azure_current_url as string
dim sample_timer as word
dim sensor_channel as byte
dim pic_channel as byte
dim device_awake_timer as word
dim sleep_time as word
dim upgrade_state as byte = 255  'upgrade over air state, 0~7(above) indicate the parts that is being downloading, 255: no upgrade in progress, 254: whole file completed
dim app_fw_size as dword=4294836225
dim app_fw_filenum as byte = 255
dim app_fw_checksum as dword
dim part_size as dword=4294836225
dim part_filenum as byte = 255
dim part_checksum as dword
dim http_conn_timeout as no_yes = NO
dim total_chuncks as byte = 0
dim part_num as byte = 255
dim battery_level as byte = 0
dim property_modified as no_yes = YES
dim sensor_telemetry_ts as string(36) = ""
dim modbus_device_id as byte
dim device_migrate as no_yes = NO
dim new_dvid as string(32)
dim new_scid as string(16) 
dim new_pkey as string(64)
dim provision_failed as no_yes = NO
dim rand_event_num as byte 
dim command_issued as no_yes = NO

declare sub device_sampling()
declare sub device_migrating()
declare function get_json_value(byref json_str as string, byref attribute as string) as string 
declare sub time_to_str(byref ts_str as string(20),	
	byref time_daycount as word,
	byref time_mincount as word,
	byref time_second_byte as byte)

declare sub device_sleep()
declare sub device_store_app_fw(data as string)
declare sub read_onboard_t_h_co2_sensor(byref ts as string)
declare sub read_onboard_t_h_sensor(byref ts as string)
declare function add_telemetry(byref telemetry_name as string, byref telemetry_value as string, byref ts as string) as en_tbl_status_codes
declare sub update_stg_ts_and_send_azure(byref stg_name as string)
declare sub update_server_properties()
declare function turn_sensor3v3_on() as boolean
declare function turn_sensor3v3_off() as boolean
declare sub read_modbus_bp02()
declare sub read_modbus_soil()
declare sub proc_modbus_bp2(byref request_item as modbus_request_item, byref reply as string)
declare sub proc_modbus_soil(byref request_item as modbus_request_item, byref reply as string)
declare sub co2_calibration()
declare sub execute_special_command()

sub device_proc_timer()	
	'deduct device_awake_timer only when device is not doing upgrade and in Low power mode
'	if upgrade_state = 255 then
		if operation_mode > 0 then
			if device_awake_timer>0 then
				device_awake_timer=device_awake_timer-1
			else
				'check if sensor sample has been taken before go to sleep
				if sample_timer > 0 then
					device_awake_timer = 1
				else
					device_sleep()
				end if
			end if
		end if		
		device_migrating()		
'	else
	if upgrade_state <> 255 then
		if http_conn_timeout = YES then
			http_conn_timeout = NO
			connect_to_azure_server()
		end if
	end if
	device_sampling()
	execute_special_command()
end sub

sub callback_stg_error(byref stg_name_or_num as string,index as byte,status as en_stg_status_codes)
    
end sub

sub callback_stg_pre_get(byref stg_name_or_num as string,index as byte,byref stg_value as string)
	dim debug_string as string = ""
	
	select case stg_name_or_num
		case "DH":
			stg_value=wln.autodhcp
			debug_string="WiFi DHCP: " + stg_value
		case "WAP":
			stg_value=wln.autoconnectssid
			debug_string="WiFi Access Point: " + stg_value
		case "WPW":
			stg_value=wln.autoconnectpassword
			debug_string="WiFi Password: " + stg_value
		case else:
	end select

	#if DEVICE_DEBUG_PRINT
		if debug_string<>"" then
			device_debug_print(debug_string)
		end if
	#endif

end sub    

sub callback_stg_post_set(byref stg_name_or_num as string, index as byte,byref stg_value as string)
	dim debug_string as string = ""

    select case stg_name_or_num

	case "DH":
		wln.autodhcp = stg_value
		debug_string="WiFi DHCP: " + stg_value
	case "WAP":
		wln.autoconnectssid = stg_value
		debug_string="WiFi Access Point: " + stg_value
	case "WPW":
		wln.autoconnectpassword = stg_value
		debug_string="WiFi Password: " + stg_value
	case "SPT":
		sleep_time = val(stg_value)
	case "RCN":
		min_rec_num_to_send = val(stg_value)
    end select
	
	#if DEVICE_DEBUG_PRINT
		if debug_string<>"" then
			device_debug_print(debug_string)
		end if
	#endif	
end sub
        
sub callback_stg_eeprom_set(byref stg_name_or_num as string, index as byte,byref stg_value as string)
	
	'use stg_timestamp.ts_milsec as a flag to detect if the setting has been changed
	'set it to 0 after change occured
	stg_timestamp.ts_milsec = 0
	stg_set_ts(stg_name_or_num)
	property_modified = YES
	
	select case stg_name_or_num
		case "DVID","SCID","PKEY":
			reprovision_needed = YES
	end select
end sub

function callback_stg_vm_read(address as word) as byte
    
end function
        
sub callback_stg_vm_write(data_to_write as byte, address as word)
    
end sub

sub close_interface_sockets(interface as pl_sock_interfaces)
    dim f,sock_num_bup as byte
    dim i as word

    sock_num_bup=sock.num

    for f=0 to sock.numofsock-1
        sock.num=f
        if sock.targetinterface=interface then
            sock.discard
        end if
    next f

    i=sys.timercount

    wait_close_interface_sockets:
    for f=0 to sock.numofsock-1
        sock.num=f
        if sock.targetinterface=interface and sock.statesimple<>PL_SSTS_CLOSED and sys.timercount-i<3 and sys.timercount>=i then
            goto wait_close_interface_sockets
        end if
    next f

    sock.num=sock_num_bup

end sub

sub callback_dns_failure(status as en_dns_status_codes)
    
end sub

sub callback_dns_answer_acquired(return_type as en_dns_return_type, byref return_string as string)
    http_dns_answer_acquired(return_type, return_string)
    mqtt_dns_answer_acquired(return_type, return_string)

end sub

sub callback_dns_ok()
    
end sub

sub callback_dns_pre_buffrq(num_of_pages_required as byte)
    
end sub

sub callback_dns_buff_released()
    
end sub
        
sub callback_http_request_failed(error_message as string)
	if error_message = "Timeout" then
		http_conn_timeout = YES
	end if
end sub

sub callback_http_header_arrival(header_type as string, header_value as string)
	if header_type = "Date" then
		azure_set_datetime(header_value)
	end if
	
	if upgrade_state <> 255 then
		select case header_type
		case "Content-Length":
			part_size=lval(header_value)
			
		case "Total-Length":
			app_fw_size=lval(header_value)
			
		case "Full-Checksum":
			app_fw_checksum=lval(header_value)
			
		case "Total-Chuncks":
			total_chuncks=lval(header_value)
			
		case "Part-Checksum":
			part_checksum=lval(header_value)
		
		case "Part-Number":
			part_num=lval(header_value)
		case else:
			
		end select
	
	end if

end sub

sub callback_http_headers_complete()
    
end sub


sub callback_http_content_arrival(data as string)
    if upgrade_state = 255 then
		azure_content_arrival(data)
	else
		device_store_app_fw(data)
	end if
end sub

sub callback_http_post_data_sent_ok()
    
end sub

sub callback_http_send_post_data(remaining_content_length as dword)
    
end sub

sub callback_http_send_headers()
	dim AZURE_DEVICE_ID as string=stg_get("DVID",0)
	
	if upgrade_state = 255 then
		iot_send_headers()
	else
		http_send_headers("Content-Type","application/json")
		http_send_headers("Connection","keep-alive")
		http_send_headers("DeviceID", AZURE_DEVICE_ID)
		http_send_headers("Part", str(upgrade_state))
	end if 
end sub


sub callback_http_request_complete()
    if upgrade_state = 255 then
		azure_http_request_complete()
	end if
    
end sub

sub callback_http_response_code_arrival(http_response as string)
    
end sub

function callback_http_open_romfile() as dword
    #ifdef HTTP_CER_FILE
		romfile.open(HTTP_CER_FILE)
		callback_http_open_romfile=romfile.offset    
	
	#else 
		callback_http_open_romfile=0
	#endif    
end function

sub callback_mqtt_connect_ok()
    pat.play("G~",PL_PAT_CANINT)
    
    azure_on_connected()
end sub
        
sub callback_mqtt_connect_lost()
	azure_on_disconnected()
	azure_fail_to_connect_count = azure_fail_to_connect_count + 1
	if (new_dvid <> "" or new_scid <> "" or  new_pkey <> "") or  azure_fail_to_connect_count >= FAIL_CONN_COUNT_MAX then
		'reset hub name
		stg_set("HUBN",0,"")
		new_dvid=""
		new_scid=""
		new_pkey=""
		provision_failed = YES
	end if
end sub
        
sub callback_mqtt_notif(byref topic as string,byref data as string,remaining_bytes as dword)
    azure_proc_mqtt_msg(topic,data)	
end sub

sub callback_mqtt_sub_ok()
	azure_fail_to_connect_count = 0
	if new_dvid <> "" and new_scid <> "" and new_pkey <> "" and device_migrate = NO then
		stg_set("DVID",0,new_dvid)
		stg_set("SCID",0,new_scid)
		stg_set("PKEY",0,new_pkey)
		new_dvid=""
		new_scid=""
		new_pkey=""
	end if
end sub      

sub callback_tbl_error(status as en_tbl_status_codes)
    
end sub    

function callback_tbl_fail_to_open(byref filename as string, status as pl_fd_status_codes, filenum as byte) as no_yes
    
end function

sub callback_tbl_field_error(byref file_name as string,byref field_name as string,tbl_result as en_tbl_status_codes)
    
end sub
        

sub callback_tbl_modified(byref file_name as string, modified_operation as en_tbl_modified_operation)
    
end sub

sub callback_azure_rtc_correction(daycounts as word, mincounts as word, seconds as byte)
	'if rtc was reseted, take another sample with corrected timestample
	if daycounts = 0 and sample_timer = 0 then
		sample_timer = 1
	end if
end sub

sub callback_azure_provision_failed()
	if device_migrate = YES then
		device_add_event("Migrate failed, Device ID: "+new_dvid)
		new_dvid = ""
		new_scid = "" 
		new_pkey = ""
	end if
	provision_failed = YES
end sub

sub callback_azure_command_triggered(byref command as string, byref param as string, rid as string)

    select case command
    case "UPGRADE": 'offline command, not expecting response
		stg_set("DLPT",0,param)
		stg_set("UPD",0,"0")
		device_add_event("Upgrade start!")
		
	case "RSTNTGPW":
		pic_write(&hA3,"\x77")
		delay_ms(5)
		if pic_read(&hA3,1)="\x77" then
			stg_set("NWPR",0,"1")
			device_add_event("Password Recovery Requested.")
		end if
		
	case "DEVMIG":
		new_pkey = get_json_value(param,"PKEY")
		if right(new_pkey,1) = "=" then
			new_scid = get_json_value(param,"SCID")
			new_dvid = get_json_value(param,"DVID")
			device_add_event("Device migrate, new Device ID: " + new_dvid)
			device_migrate = YES
		else
			device_add_event("Invalid command paramters.")
			new_pkey = ""
		end if
    case else: 'by default send response.
		azure_command_respond(command,"{}",rid,EN_AZURE_OK)
    end select
  
end sub     

sub callback_azure_device_assigned(byref assigned_hub as string)
	stg_set("HUBN",0,assigned_hub)
end sub

sub callback_azure_get_assigned_hub(byref assigned_hub as string)
	assigned_hub = stg_get("HUBN",0)
end sub
        
sub callback_azure_conn_timeout()
    if comm_mode=1 then
		cell__start(CELL__SIMCARD_PIN, CELL__AT_APN, CELL__MYUSERNAME, CELL__MYPASSWORD)
	else
		azure_on_disconnected()
		azure_fail_to_connect_count = azure_fail_to_connect_count + 1
		if azure_fail_to_connect_count >= FAIL_CONN_COUNT_MAX then
			'reset hub name
			stg_set("HUBN",0,"")
			provision_failed = YES
		end if	
	end if
end sub

sub callback_azure_on_telemetry_sent()
	dim active_rec_num as word
	
	update_server_properties()
	
	tbl_select("Azure","Azure")
	tbl_get_num_records(active_rec_num,NO)
	if active_rec_num>0 then
		azure_send_telemetry()
	else
		if operation_mode > 0 then 
			device_awake_timer = 1 'go to sleep
		else
			upgrade_state = val(stg_get("UPD",0))
			if upgrade_state <> 255 then
				connect_to_firmware_server()
			end if
		end if
	end if

end sub        

public sub callback_azure_on_provisioning()

end sub

sub callback_azure_on_connected()
	azure_send_telemetry()

end sub

sub callback_azure_on_disconnected()

end sub

sub callback_azure_update_twin_version(byref ver as string)
	
end sub

sub callback_luis_bt_connected()
    
end sub

sub callback_luis_bt_disconnected()
    
end sub

sub callback_luis_bt_enabled()
    
end sub

sub callback_luis_bt_disabled()
    
end sub

sub callback_luis_buzz_command()
    
end sub
'XXXXXXXXXXXXXXXXXXX USING IO EXTENDER FOR CELL        
sub cell_callback_io_extender_setup()
	mcp23017_port_config_set(&hFF,0,EXT_PORT_A,TBT00_3_S5_CHANNEL)

	'SHDN line
	mcp23017_line_out_enable(CELL__SHDN_LINENUM,CELL__SHDN_PORT,yes,TBT00_3_S5_CHANNEL)

	'Initial SHDN state should be Active
	'If False, then set to Active
	if CELL__SHDN_STATE = cell__shdn_setto_off then
		CELL__SET_SHDN_ON	'then set SHDN line to Active (by default)
	end if

	'PWRKEY line
	mcp23017_line_out_enable(CELL__PWRKEY_LINENUM,CELL__PWRKEY_PORT,yes,TBT00_3_S5_CHANNEL)

	'RESET line
	mcp23017_line_out_enable(CELL__RESET_LINENUM,CELL__RESET_PORT,yes,TBT00_3_S5_CHANNEL)
	CELL__SET_RESET_OFF

	'STATUS line
	mcp23017_line_out_enable(CELL__STATUS_LINENUM,CELL__STATUS_PORT,NO,TBT00_3_S5_CHANNEL)

	'TX_BUF line
	mcp23017_line_out_enable(TX_BUF_LINENUM,TX_BUF_PORT,yes,TBT00_3_S5_CHANNEL)
	mcp23017_line_set(TX_BUF_LINENUM,TX_BUF_PORT, HIGH, TBT00_3_S5_CHANNEL)
end sub

sub cell__callback_modem_restart_failed()
end sub

sub cell__callback_modem_on()
end sub

sub cell__callback_modem_off()
end sub

sub cell__callback_insufficient_buffer_pages()
end sub

sub cell__callback_at_reply()
end sub

sub cell__callback_at_reply_contains_error()
end sub

sub cell__callback_ppp_fcs_is_bad()
end sub

sub cell__callback_ppp_missing_address_field()
end sub

sub cell__callback_ppp_missing_control_field()
end sub

sub cell__callback_ppp_lcp_msg_length_not_matching()
end sub

sub cell__callback_ppp_lcp_successful()
end sub

sub cell__callback_ppp_lcp_disreq_from_peer()
end sub

sub cell__callback_ppp_lcp_disreq_from_sender()
end sub

sub cell__callback_ppp_retry_exceeded()
end sub

sub cell__callback_ppp_pap_successful()
end sub

sub cell__callback_ppp_pap_nego_failed()
end sub

sub cell__callback_ppp_ipcp_successful()
end sub     

sub cell__callback_ppp_ipcp_disreq_from_peer()
end sub

sub cell__callback_ppp_ipcp_disreq_from_sender()
end sub
                

sub cell__callback_ppp_ping_successful()
end sub
                

sub cell__callback_ppp_ping_failed()
end sub

sub cell__callback_ppp_link_established()
	
	if config_mode=NO then
		if upgrade_state <255 then
			connect_to_firmware_server()
		else
			connect_to_azure_server()
			pat.play("G-~",PL_PAT_CANINT)
		end if
	end if
end sub

sub cell__callback_after_switching_from_DATA_to_CMD()
end sub

sub cell__callback_after_switching_from_CMD_to_DATA()
end sub

sub device_sleep()
	dim daycounts, mincounts as word
	dim seconds as byte	

	if sleep_time=0 then
		exit sub
	end if
	mqtt_disconnect()
	rtc.getdata(daycounts,mincounts,seconds)
	if sleep_time>1440 then
		sleep_time=sleep_time-1440
		daycounts=daycounts+1
	end if
	mincounts=mincounts+sleep_time
	daycounts=daycounts+(mincounts/1440)
	mincounts=mincounts mod 1440
	turn_sensor3v3_off()
	
	if sensor_type > 127 then
		mcp23017_line_set(VMOD_SHDN_LINENUM,VMOD_SHDN_PORT,LOW,TBT00_3_S5_CHANNEL)
	end if
	'in wln mode, we decide next cycle should connect or not before go to sleep
	if comm_mode = 0 then
		wln.autoconnect = need_to_connect()
	end if
	sys.sleep(daycounts, mincounts, seconds)  
end sub

sub device_add_event(byref event_msg as string)
	dim daycounts, mincounts as word
	dim seconds as byte
	dim tbl_result as en_tbl_status_codes	
	dim ts as string(36) 
	dim f as byte
	
	rand_event_num = rand_event_num+1
	f=fd.filenum
	rtc.getdata(daycounts,mincounts,seconds)
	time_to_str(ts,daycounts,mincounts,seconds)
	
	ts=ts+"."+str(rand_event_num)+"Z"		
	tbl_result=tbl_select("Azure","Azure")
	tbl_result=tbl_field_sg("time",ts,EN_TBL_SET)
	tbl_result=tbl_field_sg("type","event",EN_TBL_SET)
	tbl_result=tbl_field_sg("value",event_msg,EN_TBL_SET)
	tbl_result=tbl_record_add("")		
	
	#if DEVICE_DEBUG_PRINT
		device_debug_print("Event: "+event_msg)
	#endif
	fd.filenum = f
end sub

function app_fw_copy_part_to_file() as ok_ng
	fd.filenum=app_fw_filenum
	fd.open(APP_FW_FILE)
	fd.setpointer(fd.filesize+1)
	fd.filenum=part_filenum
	fd.setpointer(1)
	
	'read from partfile and add to firmware file
	do
		dim data as string=fd.getdata(255)
		fd.filenum=app_fw_filenum
		if fd.setdata(data) <>PL_FD_STATUS_OK then
			exit do
		end if
		fd.filenum=part_filenum
	loop while fd.pointer < fd.filesize and fd.laststatus=PL_FD_STATUS_OK
	
	'verify checksum for whole firmware file
	fd.filenum = app_fw_filenum
	if fd.laststatus = PL_FD_STATUS_OK then
		fd.flush()
		upgrade_state = upgrade_state+1
		if upgrade_state = total_chuncks then
			dim checksum as dword=0
			fd.setpointer(1)		
			do
				dim data as string =fd.getdata(255)
				checksum=checksum+(strsum(data))
			loop while fd.pointer <= fd.filesize
			if checksum = app_fw_checksum then
				stg_set("UPD",0,"254") 'all parts downloaded
			else
				stg_set("UPD",0,"0") 'start over
			end if
		else
			stg_set("UPD",0,str(upgrade_state))
		end if
		fd.close()
 		app_fw_copy_part_to_file = OK
	else
		app_fw_copy_part_to_file = NG
	end if
end function

sub device_store_app_fw(data as string)
	dim filenum as byte
	dim filename as string
	
	if part_size = 4294836225 then exit sub
	pat.play("R-",PL_PAT_CANINT)
	'if always on mode, store data directly to the destination file.
	'otherwise stored it to partial file and only copy to destination file if partial file is varified.

	filenum = part_filenum
	filename = PART_FILE

	fd.filenum=filenum
	if fd.fileopened=NO then
		fd.open(filename)
	end if
	
	fd.setdata(data)
	
	if fd.filesize = part_size then
		fd.flush()
		dim checksum as dword=0
		fd.setpointer(1)		
		do
			data=fd.getdata(255)
			checksum=checksum+(strsum(data))
		loop while fd.pointer <= fd.filesize
		
	'checksum verify
		if checksum <> part_checksum then
			if operation_mode = 0 then
				device_add_event("Upgrade failed, retry..")
			else
				device_add_event("Upgrade failed, retry..")
				stg_set("UPD",0,"0") 'start over
				'device_upgrade_start()				
			end if
			exit sub
		end if
	else
		exit sub
	end if

	if app_fw_copy_part_to_file() = OK then
		device_add_event(+str(part_num+1)+"/"+str(total_chuncks)+" downloaded")
	else	
		device_add_event("Upgrade failed, retry..")
		stg_set("UPD",0,"0") 'start over		
	end if
	'in power saving mode, connect to azure to finish other task
	connect_to_azure_server()
	
end sub

public sub upgrade_app_fw_init()
	upgrade_state = val(stg_get("UPD",0))
	if upgrade_state = 255 then exit sub
	
	if app_fw_filenum = 255 then app_fw_filenum = filenum_get("FMW")
	if part_filenum = 255 then 
		part_filenum = filenum_get("PAR")
		fd.filenum=part_filenum
		fd.delete(PART_FILE)
		fd.create(PART_FILE)
	else
		fd.filenum=part_filenum
		fd.setfilesize(0)
	end if

	if upgrade_state = 0 then
		fd.filenum=app_fw_filenum
		fd.delete(APP_FW_FILE)
		fd.create(APP_FW_FILE)		
	end if
	
	if upgrade_state = 254 then
		stg_set("UPD",0,"255")
		fd.filenum = app_fw_filenum
		if fd.open(APP_FW_FILE) = PL_FD_STATUS_OK then
			device_add_event("Download Completed, flashing firmware! ")
			'keep ACSIP alive
			mcp23017_line_out_enable(PMU_INHIBIT_LINE,PMU_INHIBIT_PORT,yes,TBT00_3_S5_CHANNEL)
			mcp23017_line_set(PMU_INHIBIT_LINE, PMU_INHIBIT_PORT, LOW, TBT00_3_S5_CHANNEL)
			fd.copyfirmwarefromfilelzo()
		end if
	end if
	
end sub

public sub connect_to_firmware_server()
	dim url as string
	
	mqtt_disconnect()
	http_stop()
	dns_disconnect()
	if sock.tlscurrentnum<>255 then
		sock.num=sock.tlscurrentnum
		sock.tlsdeinit()	
		if sock.statesimple = PL_SSTS_EST then
			sock.discard()
		end if
	end if
	upgrade_app_fw_init()
	url=stg_get("DLPT",0)
	http_request(HTTP_GET, url, current_interface,"")		
end sub

public sub connect_to_azure_server()		
	dim AZURE_DEVICE_ID as string=stg_get("DVID",0)
	dim AZURE_SCOPE_ID as string=stg_get("SCID",0)
	dim AZURE_DPS_SERVER as string=stg_get("DPSS",0)
	dim AZURE_PRIMARY_KEY as string=stg_get("PKEY",0)
	
	if connect_to_azure_required = NO then
		exit sub
	end if
	
	'when switching between server making sure all previous connection is closed
	http_stop()
	dns_disconnect()
	mqtt_disconnect()
	
	if sock.tlscurrentnum<>255 then
		sock.num=sock.tlscurrentnum
		sock.tlsdeinit()	
		if sock.statesimple = PL_SSTS_EST then
			sock.discard()
		end if
	end if
	upgrade_state=255
	azure_start(AZURE_DEVICE_ID,AZURE_SCOPE_ID,AZURE_DPS_SERVER,AZURE_PRIMARY_KEY,current_interface)
end sub

' This function is to read the sensor board that has a local MCU on it and T/H and CO2 sensor is populated on it
sub read_onboard_t_h_co2_sensor(byref ts as string)
	dim data0, data1, data2, data3, data4, data5, data6, data7 as byte
	dim tmp1,hi,lo,temp2 as byte
	dim co2, humidity, temperature as float
	dim humd,temp,str_co2,error as string(36)
	
	sensor_channel = si2c_register("SNR", SENSOR_DAT_PIN, SENSOR_CLK_PIN, NO)
	si2c_get(sensor_channel)
	
	'fetch temperature and humidity data

	si2c_start()
	si2c_write(SENSOR_ADDR OR PIC_WR)
	si2c_write(&h80)

	delay_ms(5)
	
	si2c_start()
	si2c_write(SENSOR_ADDR OR PIC_RD)
	data0=si2c_read(true)
	data1=si2c_read(true)
	data2=si2c_read(true)
	data3=si2c_read(true)
	data4=si2c_read(false)
	si2c_stop()
	 
	'fetch CO2 data

	si2c_start()
	si2c_write(SENSOR_ADDR OR PIC_WR)
	si2c_write(&h90)

	delay_ms(5)
	
	si2c_start()
	si2c_write(SENSOR_ADDR OR PIC_RD)
	data5=si2c_read(true)
	data6=si2c_read(true)
	data7=si2c_read(false)
	
	si2c_stop()

' Calculation
	tmp1=data1*4
	humidity=tmp1*64+data2

	tmp1=data3*4
	tmp1=tmp1/16
	hi=data3/64*16
	hi=hi+tmp1

	tmp1=data3 and &h03
	tmp1=tmp1*64

	temp2=data4 and &hC0
	temp2=temp2/4
	lo=tmp1+temp2

	tmp1=data4 and &h3C
	tmp1=tmp1/4
	lo=lo+tmp1

	temperature=hi*256+lo
	humidity=(humidity*100)/16383

	temperature=temperature/16383
	temperature=temperature*165
	
	co2=data6
	co2=co2*256+data7
	humd=ftostr(humidity,FTOSTR_MODE_AUTO,5)
	temp=ftostr(temperature,FTOSTR_MODE_AUTO,5)
	str_co2=ftostr(co2,FTOSTR_MODE_AUTO,5)
	
	error=hex(data5)
	error=right(error,len(error)-2)

	if temperature > -40 and temperature < 85 then
		add_telemetry("temperature",temp,ts)
	else
		device_add_event("Sensor value out of range [temp]: " + temp)
	end if
	
	if humidity > 0 and humidity < 100 then
		add_telemetry("humidity",humd,ts)
	else
		device_add_event("Sensor value out of range [humd]: " + humd)
	end if

	if co2 > 1 and co2 < 10000 then
		add_telemetry("co2",str_co2,ts)
	else
		device_add_event("Sensor value out of range [co2]: " + str_co2)
	end if
	
	'in power saving mode log battery level
	if operation_mode = 1 then
		add_telemetry("BAT_LVL",str(battery_level),ts)
	end if
	
	#if DEVICE_DEBUG_PRINT
		device_debug_print(temp+"C "+humd+"% "+str_co2)
	#endif
end sub
' This function is to read the sensor board that has a local MCU on it and T/H sensor is populated on it but CO2 sensor is NOT populated on it
sub read_onboard_t_h_sensor(byref ts as string)
	dim data0, data1, data2, data3, data4 as byte
	dim tmp1,hi,lo,temp2 as byte
	dim humidity, temperature as float
	dim humd,temp as string(36)
	
	sensor_channel = si2c_register("SNR", SENSOR_DAT_PIN, SENSOR_CLK_PIN, NO)
	si2c_get(sensor_channel)
	
	'fetch temperature and humidity data

	si2c_start()
	si2c_write(SENSOR_ADDR OR PIC_WR)
	si2c_write(&h80)

	delay_ms(5)
	
	si2c_start()
	si2c_write(SENSOR_ADDR OR PIC_RD)
	data0=si2c_read(true)
	data1=si2c_read(true)
	data2=si2c_read(true)
	data3=si2c_read(true)
	data4=si2c_read(false)
	si2c_stop()
	
' Calculation
	tmp1=data1*4
	humidity=tmp1*64+data2

	tmp1=data3*4
	tmp1=tmp1/16
	hi=data3/64*16
	hi=hi+tmp1

	tmp1=data3 and &h03
	tmp1=tmp1*64

	temp2=data4 and &hC0
	temp2=temp2/4
	lo=tmp1+temp2

	tmp1=data4 and &h3C
	tmp1=tmp1/4
	lo=lo+tmp1

	temperature=hi*256+lo
	humidity=(humidity*100)/16383

	temperature=temperature/16383
	temperature=temperature*165
	'temperature=temperature-40
	
	humd=ftostr(humidity,FTOSTR_MODE_AUTO,5)
	temp=ftostr(temperature,FTOSTR_MODE_AUTO,5)
	
	if temperature > -40 and temperature < 85 then
		add_telemetry("temperature",temp,ts)
	else
		device_add_event("Sensor value out of range [temp]: " + temp)
	end if
	
	if humidity > 0 and humidity < 100 then
		add_telemetry("humidity",humd,ts)
	else
		device_add_event("Sensor value out of range [humd]: " + humd)
	end if

	'in power saving mode log battery level
	if operation_mode = 1 then
		add_telemetry("BAT_LVL",str(battery_level),ts)
	end if

	#if DEVICE_DEBUG_PRINT
		device_debug_print(temp+"C "+humd+"% ")
	#endif
end sub

sub read_modbus_bp02()
	dim daycounts, mincounts as word 
	dim seconds as byte
	
	rtc.getdata(daycounts,mincounts,seconds)
	time_to_str(sensor_telemetry_ts,daycounts,mincounts,seconds)
	sensor_telemetry_ts=sensor_telemetry_ts+".000Z"
	modbus_master_request(modbus_device_id, ReadInputRegisters, 400, 1, "", MODBUS_UART, modbus_RTU) 'temperature
	modbus_master_request(modbus_device_id, ReadInputRegisters, 404, 1, "", MODBUS_UART, modbus_RTU) 'humidity

end sub

sub read_modbus_soil()
	dim daycounts, mincounts as word 
	dim seconds as byte
	
	rtc.getdata(daycounts,mincounts,seconds)
	time_to_str(sensor_telemetry_ts,daycounts,mincounts,seconds)
	sensor_telemetry_ts=sensor_telemetry_ts+".000Z"
	modbus_master_request(modbus_device_id, ReadHoldingRegisters, 2, 2, "", MODBUS_UART, modbus_RTU) 'humidity + temperature 
	
end sub

sub pic_write(addr as byte, byref data as string)
	dim i as byte
	
	si2c_get(pic_channel)
	si2c_start()
	si2c_write(PIC_ADDR OR PIC_WR)
	si2c_write(addr)
	for i = 1 to len(data)
		delay_ms(10)
		si2c_write(asc(mid(data,i,1)))
	next i
	delay_ms(10)
	si2c_stop()
end sub

function pic_read(addr as byte, length as byte) as string
	dim i as byte
	
	pic_read=""
	si2c_get(pic_channel)
	si2c_start()
	si2c_write(PIC_ADDR OR PIC_WR)	
	si2c_write(addr)		'Set reg num
	si2c_start()
	si2c_write(PIC_ADDR OR PIC_RD)
	for i = 1 to length-1
		delay_ms(10)
		pic_read = pic_read + chr(si2c_read(true))
	next i
	delay_ms(10)
	pic_read = pic_read + chr(si2c_read(false))
	delay_ms(10)
	si2c_stop()
end function

function add_telemetry(byref telemetry_name as string, byref telemetry_value as string, byref ts as string) as en_tbl_status_codes
	
	add_telemetry=tbl_select("Azure","Azure")
	if add_telemetry<>EN_TBL_STATUS_OK then exit function
	add_telemetry=tbl_field_sg("time",ts,EN_TBL_SET)
	if add_telemetry<>EN_TBL_STATUS_OK then exit function
	add_telemetry=tbl_field_sg("type",telemetry_name,EN_TBL_SET)
	if add_telemetry<>EN_TBL_STATUS_OK then exit function	
	add_telemetry=tbl_field_sg("value",telemetry_value,EN_TBL_SET)
	if add_telemetry<>EN_TBL_STATUS_OK then exit function	
	add_telemetry=tbl_record_add("")	
end function

function need_to_connect() as no_yes
	dim active_rec_num as word
	dim number_of_fld as byte
	dim daycounts, mincounts as word
	dim seconds as byte
	
	need_to_connect = NO
	
	rtc.getdata(daycounts,mincounts,seconds)
	if operation_mode = 0 or daycounts = 0 then
		need_to_connect=YES
		exit function
	end if
	
	select case sensor_type
	case 0, 128, 129: 
		number_of_fld = 2
		
	case 1: 
		number_of_fld = 3
	
	case else:	
	end select
	
	'in power saving mode log battery level
	if operation_mode = 1 then number_of_fld = number_of_fld+1
	
	tbl_select("Azure","Azure")
	tbl_get_num_records(active_rec_num,NO)
	active_rec_num=active_rec_num/number_of_fld
	min_rec_num_to_send=val(stg_get("RCN",0))
	if active_rec_num >= min_rec_num_to_send-1 then
		need_to_connect = YES
	end if
end function

sub update_stg_ts_and_send_azure(byref stg_name as string)
	dim stg_val as string
	
	'use stg_timestamp.ts_milsec as a flag to detect if the setting has been changed
	'push to server if it is 0, and set it to 999 after push
	stg_val=stg_get(stg_name,0)
	if stg_timestamp.ts_milsec = 0 then
		azure_send_property(stg_name, stg_val)
		stg_timestamp.ts_milsec = 999
		stg_set_ts(stg_name)
	end if	
end sub

function modbus_callback_ReadCoilStatus(address as word) as boolean
	
end function

function modbus_callback_ReadInputStatus(address as word) as boolean
	
end function

function modbus_callback_WriteSingleCoil(address as word, value as low_high) as byte 
	
end function

function modbus_callback_ReadHoldingRegister(address as word) as word
	
end function

function modbus_callback_ReadInputRegister(address as word) as word
	
end function

function modbus_callback_set_holding_register(address as word, data as word) as boolean
	
end function

function modbus_set_holding_register(address as word, data as string) as boolean
	
end function

sub callback_modbus_slave_reply_timeout(byref request_item as modbus_request_item)
	sample_timer = 10
end sub

sub callback_modbus_slave_reply(byref request_item as modbus_request_item, byref reply as string)

	if request_item.device_id = modbus_device_id then
		select case sensor_type
		case 128: proc_modbus_bp2(request_item, reply)
		case 129: proc_modbus_soil(request_item, reply)
		end select
	end if
end sub

sub proc_modbus_soil(byref request_item as modbus_request_item, byref reply as string)
	dim bytes as byte(255) = reply
	dim humd, temp as string(36)
	dim tbl_result as en_tbl_status_codes	
	
	if request_item.start_register=2 then
		dim SOIL_Humidity_val as word = modbus_read_word(bytes,0)
		dim SOIL_Temperature_val as short = modbus_read_word(bytes,2)
		temp=stri(SOIL_Temperature_val)
		if SOIL_Temperature_val<>0 then temp=left(temp,len(temp)-1)+"."+right(temp,1)
		
		humd=str(SOIL_Humidity_val)
		if SOIL_Humidity_val<>0 then humd=left(humd,len(humd)-1)+"."+right(humd,1)		

		#if DEVICE_DEBUG_PRINT
			device_debug_print(temp+"C ")		
			device_debug_print(humd+" RH")
		#endif
		
		tbl_result=tbl_select("Azure","Azure")
		tbl_result=tbl_field_sg("time",sensor_telemetry_ts,EN_TBL_SET)
		tbl_result=tbl_field_sg("type","temperature",EN_TBL_SET)
		tbl_result=tbl_field_sg("value",temp,EN_TBL_SET)	
		tbl_result=tbl_record_add("")
		
		tbl_result=tbl_field_sg("time",sensor_telemetry_ts,EN_TBL_SET)
		tbl_result=tbl_field_sg("type","humidity",EN_TBL_SET)
		tbl_result=tbl_field_sg("value",humd,EN_TBL_SET)			
		tbl_result=tbl_record_add("")	
	end if	
end sub

sub proc_modbus_bp2(byref request_item as modbus_request_item, byref reply as string)
	dim bytes as byte(255) = reply
	dim temp as string(36)
	dim tbl_result as en_tbl_status_codes	
	
	if request_item.start_register=400 then
		dim BP_02_Temperature_val as short = modbus_read_word(bytes,0)
		temp=stri(BP_02_Temperature_val)
		if BP_02_Temperature_val <> 0 then temp=left(temp,len(temp)-1)+"."+right(temp,1)

		#if DEVICE_DEBUG_PRINT
			device_debug_print(temp+"C ")
		#endif			
		tbl_result=tbl_select("Azure","Azure")
		tbl_result=tbl_field_sg("time",sensor_telemetry_ts,EN_TBL_SET)
		tbl_result=tbl_field_sg("type","temperature",EN_TBL_SET)
		tbl_result=tbl_field_sg("value",temp,EN_TBL_SET)				
		tbl_result=tbl_record_add("")	
	end if
	
	if request_item.start_register=404 then
		dim BP_02_Humidity_val as word = modbus_read_word(bytes,0)
		temp=str(BP_02_Humidity_val)
		temp=left(temp,len(temp)-1)+"."+right(temp,1)

		#if DEVICE_DEBUG_PRINT
			device_debug_print(temp+" RH")
		#endif			
		
		tbl_result=tbl_select("Azure","Azure")
		tbl_result=tbl_field_sg("time",sensor_telemetry_ts,EN_TBL_SET)
		tbl_result=tbl_field_sg("type","humidity",EN_TBL_SET)
		tbl_result=tbl_field_sg("value",temp,EN_TBL_SET)				
		tbl_result=tbl_record_add("")	
	end if

end sub

sub update_server_properties()

	if property_modified = YES then
		update_stg_ts_and_send_azure("FWV")
		update_stg_ts_and_send_azure("CID")	
		update_stg_ts_and_send_azure("DLPT")		
		property_modified = NO
	end if
end sub

public function turn_sensor3v3_on() as boolean
	pic_write(&hA0,"\x77")
	delay_ms(5)
	if pic_read(&hA0,1)="\x77" then
		turn_sensor3v3_on=true
	else
		turn_sensor3v3_on=false
	end if
end function

public function turn_sensor3v3_off() as boolean
	pic_write(&hA0,"\x00")
	delay_ms(5)
	if pic_read(&hA0,1)="\x00" then
		turn_sensor3v3_off=true
	else
		turn_sensor3v3_off=false
	end if
end function

function get_json_value(byref json_str as string, byref attribute as string) as string
	dim attr as string = "\x22"+attribute+"\x22:\x22"
	dim l as byte = len(attr)
	dim pos1 as byte = instr(1, json_str, attr, 1) + l
	dim pos2 as byte = instr(pos1, json_str, "\x22",1)
	
	get_json_value = mid(json_str, pos1,pos2-pos1)
end function

sub device_sampling()

	if sample_timer>0 then
		sample_timer=sample_timer-1
		if sample_timer = 0 then
		
			dim daycounts, mincounts as word
			dim seconds as byte		
			dim ts as string(36)		
			
			'check the timestampe, if it's invalid, don't sample, but sample again in 2 sec
			rtc.getdata(daycounts,mincounts,seconds)
			if daycounts>0 then
				time_to_str(ts,daycounts,mincounts,seconds)
				ts=ts+".000Z"
				
				select case sensor_type
				case 0:
					read_onboard_t_h_sensor(ts)	
				case 1:
					read_onboard_t_h_co2_sensor(ts)			
				case 128:
					read_modbus_bp02()
				case 129:
					read_modbus_soil()
				case else:
				end select

				'in Low power mode, and not sending cycle, go to sleep after taking sample
				if operation_mode > 0 then
					if connect_to_azure_required = NO and sample_timer = 0 then
						device_awake_timer = 1
					end if
				else
					'when in Always on mode, sample time is same as sleep time
					sample_timer = sleep_time*120
				end if
				azure_send_telemetry()
			else
				sample_timer = 20
				#if DEVICE_DEBUG_PRINT
					device_debug_print("Bad timestampe, skip sensor sampling")
				#endif					
			end if
		end if	
	end if 	
end sub

sub device_migrating()
	if device_migrate = YES then
		device_migrate = NO
		property_modified = YES
		mqtt_disconnect()
		http_stop()
		dns_disconnect()
		 
		if sock.tlscurrentnum<>255 then
			sock.num=sock.tlscurrentnum
			sock.tlsdeinit()	
			if sock.statesimple = PL_SSTS_EST then
				sock.discard()
			end if
		end if
		upgrade_state=255
		stg_set("HUBN",0,"") 'clear hub name
		dim AZURE_DPS_SERVER as string=stg_get("DPSS",0)
		azure_start(new_dvid,new_scid, AZURE_DPS_SERVER,new_pkey,current_interface)	'establish conn with new parameters
	end if
	
	if provision_failed = YES then
		provision_failed = NO
		connect_to_azure_server()
	end if		
			
end sub

sub co2_calibration()
	dim i as byte
	
	si2c_get(sensor_channel)
	si2c_start()
	si2c_write(SENSOR_ADDR OR PIC_WR)
	si2c_write(&hA0)
	si2c_write(&h77)
	delay_ms(10)
	si2c_stop()
	 
end sub

sub execute_special_command()
	if command_issued = NO then exit sub
	dim cmd as string(32) = stg_get("CMD",0)
	if sensor_type = 1 and cmd = "CO2 CALRIBRATION" then 
		co2_calibration()
		sample_timer = 60
		stg_set("CMD",0,"")
		command_issued = NO
	end if 	
end sub

sub delay_ms(ms as dword)
#if PLATFORM_ID=TPP2W or PLATFORM_ID=TPP2N or PLATFORM_ID=TPP3W or PLATFORM_ID=TPP3N
	dim ax,bx as word

	for ax=0 to ms
		for bx=0 to 5
		next bx
	next ax
#else
	dim t as dword = sys.timercountms + ms
	while sys.timercountms < t
	wend
#endif

end sub

#if DEVICE_DEBUG_PRINT
sub device_debug_print(byref data as string)

	#if SYS_SOCK_DEBUGPRINT or SYS_EVENT_DEBUGPRINT
		alternate_debugprint(MQTT_STAMP+data+MQTT_CR_LF)
	#else
		sys.debugprint(data+"\r\n")
	#endif
end sub
#endif