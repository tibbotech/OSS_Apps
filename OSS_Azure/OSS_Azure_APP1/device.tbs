include "global.tbh"

const CELL__SIMCARD_PIN = CELL__QUESTMARK	'<-- CHANGE THIS AS NEEDED
const UPGRADE_TIMEOUT = 30

dim azure_current_url as string
dim sample_timer as word
dim sensor_channel as byte
dim pic_channel as byte
dim device_awake_timer as word
dim sleep_time as word
dim upgrade_state as byte = 255  
dim fimrware_size as dword=4294836225
dim firmware_filenum as byte
dim firmware_checksum as dword
dim part_size as dword=4294836225
dim part_filenum as byte
dim part_checksum as dword
dim upgrade_timer as byte = 0
dim total_chuncks as byte = 0
dim part_num as byte = 255
dim battery_level as byte = 0
dim property_modified as no_yes = YES
dim upgrade_trigger as byte = 0
dim sensor_telemetry_ts as string(36) = ""
dim modbus_device_id as byte

declare sub time_to_str(byref ts_str as string(20),	
	byref time_daycount as word,
	byref time_mincount as word,
	byref time_second_byte as byte)

declare sub device_sleep()
declare sub device_upgrade_start()
declare sub device_store_firmware(data as string)
declare sub read_onboard_hum_temp_legacy()
declare sub read_onboard_t_h_co2_sensor()
declare sub read_onboard_t_h_sensor()
declare function add_telemetry(byref telemetry_name as string, byref telemetry_value as string, byref ts as string) as en_tbl_status_codes
declare sub update_stg_ts_and_send_azure(byref stg_name as string)
declare sub update_server_properties()
declare function turn_sensor3v3_on() as boolean
declare function turn_sensor3v3_off() as boolean
declare sub read_modbus_bp02()

sub device_proc_timer()	
	'deduct device_awake_timer only when device is not doing upgrade and in Low power mode
	if upgrade_state = 255 then
		if upgrade_trigger = 1 then
			stg_set("UPGS",0,"0")
			azure_send_property("UPGS","0")
			device_upgrade_start()
		end if
		if operation_mode > 0 then
			if device_awake_timer>0 then
				device_awake_timer=device_awake_timer-1
			else
				'check if sensor sample has been taken before go to sleep
				if sample_timer > 0 then
					device_awake_timer = 1
				else
					device_sleep()
				end if
			end if
		end if
	else
		upgrade_timer = upgrade_timer + 1
		if upgrade_timer > UPGRADE_TIMEOUT then
			connect_to_azure_server()
		end if
	end if

	if sample_timer>0 then
		sample_timer=sample_timer-1
		if sample_timer = 0 then
			select case sensor_type
			case 0:
				read_onboard_hum_temp_legacy()
			case 1:
				read_onboard_t_h_sensor()	
			case 2:
				read_onboard_t_h_co2_sensor()
			case 128:
				read_modbus_bp02()
			case else:
			end select
			
			'in Low power mode, and not sending cycle, go to sleep after taking sample
			if operation_mode > 0 then
				if connect_to_network = NO and sample_timer = 0 then
					device_sleep()
				end if
			else
				'when in Always on mode, sample time is same as sleep time
				sample_timer = sleep_time*120
			end if			
		end if	
		azure_send_telemetry()
	end if 

end sub

sub callback_stg_error(byref stg_name_or_num as string,index as byte,status as en_stg_status_codes)
    
end sub

sub callback_stg_pre_get(byref stg_name_or_num as string,index as byte,byref stg_value as string)
	select case stg_name_or_num
		case "WAP":
			stg_value=wln.autoconnectssid
			sys.debugprint("WiFi Access Point: " + stg_value + "\r\n")		
		case "WPW":
			stg_value=wln.autoconnectpassword
			sys.debugprint("WiFi Password: " + stg_value + "\r\n")					
		case else:
	end select
        
end sub    

sub callback_stg_post_set(byref stg_name_or_num as string, index as byte,byref stg_value as string)
    select case stg_name_or_num
	case "UPGS":
		upgrade_trigger = val(stg_value)
		
	case "WAP":
		wln.autoconnectssid = stg_value
		sys.debugprint("WiFi Access Point: " + stg_value + "\r\n")		
	case "WPW":
		wln.autoconnectpassword = stg_value
		sys.debugprint("WiFi Password: " + stg_value + "\r\n")		
	case "SPT":
		sleep_time = val(stg_value)
	case "RCN":
		min_rec_num_to_send = val(stg_value)
    end select
end sub
        
sub callback_stg_eeprom_set(byref stg_name_or_num as string, index as byte,byref stg_value as string)
	
	'use stg_timestamp.ts_milsec as a flag to detect if the setting has been changed
	'set it to 0 after change occured
	stg_timestamp.ts_milsec = 0
	stg_set_ts(stg_name_or_num)
	property_modified = YES
end sub

function callback_stg_vm_read(address as word) as byte
    
end function
        
sub callback_stg_vm_write(data_to_write as byte, address as word)
    
end sub

sub close_interface_sockets(interface as pl_sock_interfaces)
    dim f,sock_num_bup as byte
    dim i as word

    sock_num_bup=sock.num

    for f=0 to sock.numofsock-1
        sock.num=f
        if sock.targetinterface=interface then
            sock.discard
        end if
    next f

    i=sys.timercount

    wait_close_interface_sockets:
    for f=0 to sock.numofsock-1
        sock.num=f
        if sock.targetinterface=interface and sock.statesimple<>PL_SSTS_CLOSED and sys.timercount-i<3 and sys.timercount>=i then
            goto wait_close_interface_sockets
        end if
    next f

    sock.num=sock_num_bup

end sub

sub callback_dns_failure(status as en_dns_status_codes)
    
end sub

sub callback_dns_answer_acquired(return_type as en_dns_return_type, byref return_string as string)
    
    http_dns_answer_acquired(return_type, return_string)

    mqtt_dns_answer_acquired(return_type, return_string)

    'if return_type=EN_DNS_RET_IP then
    '    sys.debugprint("DNS:" + ddstr(return_string) + "\r\n")
    'end if
end sub

sub callback_dns_ok()
    
end sub

sub callback_dns_pre_buffrq(num_of_pages_required as byte)
    
end sub

sub callback_dns_buff_released()
    
end sub
        
sub callback_http_request_failed(error_message as string)

end sub

sub callback_http_header_arrival(header_type as string, header_value as string)
	if upgrade_state = 255 then
		iot_header_arrival(header_type, header_value)
	else
		select case header_type
		case "Content-Length":
			part_size=lval(header_value)
			
		case "Total-Length":
			fimrware_size=lval(header_value)
			
		case "Full-Checksum":
			firmware_checksum=lval(header_value)
			
		case "Total-Chuncks":
			total_chuncks=lval(header_value)
			
		case "Part-Checksum":
			part_checksum=lval(header_value)
		
		case "Part-Number":
			part_num=lval(header_value)
		case else:
			
		end select
		if operation_mode = 0 then 
			total_chuncks = 1
			part_num = 0
		end if		
	end if

end sub

sub callback_http_headers_complete()
    
end sub


sub callback_http_content_arrival(data as string)
    if upgrade_state = 255 then
		azure_content_arrival(data)
	else
		device_store_firmware(data)
	end if
end sub

sub callback_http_post_data_sent_ok()
    
end sub

sub callback_http_send_post_data(remaining_content_length as dword)
    
end sub

sub callback_http_send_headers()
	dim AZURE_DEVICE_ID as string=stg_get("DVID",0)
	
	if upgrade_state = 255 then
		iot_send_headers()
	else
		http_send_headers("Content-Type","application/json")
		http_send_headers("Connection","keep-alive")
		http_send_headers("DeviceID", AZURE_DEVICE_ID)
		
		if operation_mode>0 then
			http_send_headers("Part", str(upgrade_state))
		end if
	end if 
end sub


sub callback_http_request_complete()
    if upgrade_state = 255 then
		azure_http_request_complete()
	end if
    
end sub

sub callback_http_response_code_arrival(http_response as string)
    
end sub

function callback_http_open_romfile() as dword
    #ifdef HTTP_CER_FILE
		romfile.open(HTTP_CER_FILE)
		callback_http_open_romfile=romfile.offset    
	
	#else 
		callback_http_open_romfile=0
	#endif    
end function

sub callback_mqtt_connect_ok()
    pat.play("G~",PL_PAT_CANINT)
    
    azure_on_connected()
end sub
        
sub callback_mqtt_connect_lost()
	azure_on_disconnected()
end sub
        
sub callback_mqtt_notif(byref topic as string,byref data as string,remaining_bytes as dword)
    azure_proc_mqtt_msg(topic,data)	
end sub

sub callback_mqtt_sub_ok()
	
end sub      

sub callback_tbl_error(status as en_tbl_status_codes)
    
end sub    

function callback_tbl_fail_to_open(byref filename as string, status as pl_fd_status_codes, filenum as byte) as no_yes
    
end function

sub callback_tbl_field_error(byref file_name as string,byref field_name as string,tbl_result as en_tbl_status_codes)
    
end sub
        

sub callback_tbl_modified(byref file_name as string, modified_operation as en_tbl_modified_operation)
    
end sub

sub callback_azure_rtc_correction(daycounts as word, mincounts as word, seconds as byte)
	'if rtc was reseted, take another sample with corrected timestample
	if daycounts = 0 and sample_timer = 0 then
		sample_timer = 1
	end if
end sub


sub callback_azure_command_triggered(byref command as string, byref param as string, rid as string)

'    select case command
'    case "upgrade":
'		device_upgrade_start()
'		azure_command_respond(command,"{}",rid,EN_AZURE_OK)
'    case else:
'    end select
  
end sub     

sub callback_azure_device_assigned(byref assigned_hub as string)

end sub
        
sub callback_azure_conn_timeout()
    if comm_mode=1 then
		cell__start(CELL__SIMCARD_PIN, CELL__AT_APN, CELL__MYUSERNAME, CELL__MYPASSWORD)
	end if
end sub


sub callback_azure_on_telemetry_sent()
	dim active_rec_num as word
	
	update_server_properties()
	
	tbl_select("Azure","Azure")
	tbl_get_num_records(active_rec_num,NO)
	if active_rec_num>0 then
		azure_send_telemetry()
	else
		if operation_mode > 0 then device_awake_timer = 1 'go to sleep
	end if

end sub        

public sub callback_azure_on_provisioning()
'	callback_stg_eeprom_set("FWV",0,"")
'	callback_stg_eeprom_set("DLPT",0,"")
'	callback_stg_eeprom_set("TZ",0,"")
'	callback_stg_eeprom_set("DVNT",0,"")
'	callback_stg_eeprom_set("CID",0,"")
'	property_modified = YES
end sub

sub callback_azure_on_connected()
	azure_send_telemetry()
	
end sub

sub callback_azure_on_disconnected()

end sub

sub callback_azure_update_twin_version(byref ver as string)
	
end sub

sub callback_luis_bt_connected()
    
end sub

sub callback_luis_bt_disconnected()
    
end sub

sub callback_luis_bt_enabled()
    
end sub

sub callback_luis_bt_disabled()
    
end sub

sub callback_luis_buzz_command()
    
end sub
'XXXXXXXXXXXXXXXXXXX USING IO EXTENDER FOR CELL        
sub cell_callback_io_extender_setup()
	mcp23017_port_config_set(&hFF,0,EXT_PORT_A,TBT00_3_S5_CHANNEL)

	'SHDN line
	mcp23017_line_out_enable(CELL__SHDN_LINENUM,CELL__SHDN_PORT,yes,TBT00_3_S5_CHANNEL)

	'Initial SHDN state should be Active
	'If False, then set to Active
	if CELL__SHDN_STATE = cell__shdn_setto_off then
		CELL__SET_SHDN_ON	'then set SHDN line to Active (by default)
	end if

	'PWRKEY line
	mcp23017_line_out_enable(CELL__PWRKEY_LINENUM,CELL__PWRKEY_PORT,yes,TBT00_3_S5_CHANNEL)

	'RESET line
	mcp23017_line_out_enable(CELL__RESET_LINENUM,CELL__RESET_PORT,yes,TBT00_3_S5_CHANNEL)
	CELL__SET_RESET_OFF

	'STATUS line
	mcp23017_line_out_enable(CELL__STATUS_LINENUM,CELL__STATUS_PORT,NO,TBT00_3_S5_CHANNEL)

	'TX_BUF line
	mcp23017_line_out_enable(TX_BUF_LINENUM,TX_BUF_PORT,yes,TBT00_3_S5_CHANNEL)
	mcp23017_line_set(TX_BUF_LINENUM,TX_BUF_PORT, LOW, TBT00_3_S5_CHANNEL)
end sub

sub cell__callback_modem_restart_failed()
end sub

sub cell__callback_modem_on()
end sub

sub cell__callback_modem_off()
end sub

sub cell__callback_insufficient_buffer_pages()
end sub

sub cell__callback_at_reply()
end sub

sub cell__callback_at_reply_contains_error()
end sub

sub cell__callback_ppp_fcs_is_bad()
end sub

sub cell__callback_ppp_missing_address_field()
end sub

sub cell__callback_ppp_missing_control_field()
end sub

sub cell__callback_ppp_lcp_msg_length_not_matching()
end sub

sub cell__callback_ppp_lcp_successful()
end sub

sub cell__callback_ppp_lcp_disreq_from_peer()
end sub

sub cell__callback_ppp_lcp_disreq_from_sender()
end sub

sub cell__callback_ppp_retry_exceeded()
end sub

sub cell__callback_ppp_pap_successful()
end sub

sub cell__callback_ppp_pap_nego_failed()
end sub

sub cell__callback_ppp_ipcp_successful()
end sub     

sub cell__callback_ppp_ipcp_disreq_from_peer()
end sub

sub cell__callback_ppp_ipcp_disreq_from_sender()
end sub
                

sub cell__callback_ppp_ping_successful()
end sub
                

sub cell__callback_ppp_ping_failed()
end sub

sub cell__callback_ppp_link_established()
	
	if upgrade_state <255 then
		connect_to_firmware_server()
	else
		connect_to_azure_server()
	end if
end sub

sub cell__callback_after_switching_from_DATA_to_CMD()
end sub

sub cell__callback_after_switching_from_CMD_to_DATA()
end sub
                
sub init_pic_supervisor()
	'Init MCLR IO and Enables pic supervisor
    mcp23017_line_out_enable(EXT_MCLR_LINE,EXT_MCLR_PORT,YES,TBT00_3_S5_CHANNEL)
	mcp23017_line_set(EXT_MCLR_LINE, EXT_MCLR_PORT,  HIGH, TBT00_3_S5_CHANNEL)
end sub

sub enable_pic_supervisor()
	'Keeps pic running
	mcp23017_line_set(EXT_MCLR_LINE, EXT_MCLR_PORT,  HIGH, TBT00_3_S5_CHANNEL)
end sub

sub disable_pic_supervisor()
	'Keeps pic reset
	mcp23017_line_set(EXT_MCLR_LINE, EXT_MCLR_PORT,  LOW, TBT00_3_S5_CHANNEL)
end sub

sub device_sleep()
	dim daycounts, mincounts as word
	dim seconds as byte	

	if sleep_time=0 then
		exit sub
	end if
	
	rtc.getdata(daycounts,mincounts,seconds)
	if sleep_time>1440 then
		sleep_time=sleep_time-1440
		daycounts=daycounts+1
	end if
	mincounts=mincounts+sleep_time
	daycounts=daycounts+(mincounts/1440)
	mincounts=mincounts mod 1440
	turn_sensor3v3_off()
	'in wln mode, we decide next cycle should connect or not before go to sleep
	if comm_mode = 0 then
		wln.autoconnect = need_to_connect()
	end if
	sys.sleep(daycounts, mincounts, seconds)  
end sub

sub device_add_event(byref event_msg as string)
	dim daycounts, mincounts as word
	dim seconds as byte
	dim tbl_result as en_tbl_status_codes	
	dim ts as string(36) 
		
	rtc.getdata(daycounts,mincounts,seconds)
	time_to_str(ts,daycounts,mincounts,seconds)
	ts=ts+".000Z"		
	tbl_result=tbl_select("Azure","Azure")
	tbl_result=tbl_field_sg("time",ts,EN_TBL_SET)
	tbl_result=tbl_field_sg("type","event",EN_TBL_SET)
	tbl_result=tbl_field_sg("value",event_msg,EN_TBL_SET)
	tbl_result=tbl_record_add("")		
	
	sys.debugprint("Event: "+event_msg+"\x0a")
end sub

sub device_upgrade_start()
	stg_set("UPD",0,"0")
	device_add_event("Upgrage start!")
	azure_send_telemetry()
	
	'if running always on mode, start upgarde right away, otherwise start upgrade on next cycle
	if operation_mode = 0 then
		'when in Always on mode, send the event before switch to firmware server.
		dim d as dword = sys.timercountms
		while sock.txlen > 0 
			if sys.timercountms < d or sys.timercountms > d+1000 then
				exit while
			end if
		wend
		if sock.txlen = 0 then
			azure_on_telemetry_sent()
		end if
		upgrade_init()
		connect_to_firmware_server()
	end if
end sub

function copy_partfile_to_firmwarefile() as ok_ng
	fd.filenum=firmware_filenum
	fd.open(FIRMWARE_FILE)
	fd.setpointer(fd.filesize+1)
	fd.filenum=part_filenum
	fd.setpointer(1)
	
	'read from partfile and add to firmware file
	do
		dim data as string=fd.getdata(255)
		fd.filenum=firmware_filenum
		if fd.setdata(data) <>PL_FD_STATUS_OK then
			exit do
		end if
		fd.filenum=part_filenum
	loop while fd.pointer < fd.filesize and fd.laststatus=PL_FD_STATUS_OK
	
	'verify checksum for whole firmware file
	fd.filenum = firmware_filenum
	if fd.laststatus = PL_FD_STATUS_OK then
		fd.flush()
		upgrade_state = upgrade_state+1
		if upgrade_state = total_chuncks then
			dim checksum as dword=0
			fd.setpointer(1)		
			do
				dim data as string =fd.getdata(255)
				checksum=checksum+(strsum(data))
			loop while fd.pointer <= fd.filesize
			if checksum = firmware_checksum then
				stg_set("UPD",0,"254") 'all parts downloaded
			else
				stg_set("UPD",0,"0") 'start over
			end if
		else
			stg_set("UPD",0,str(upgrade_state))
		end if
		fd.close()
		copy_partfile_to_firmwarefile = OK
	else
		copy_partfile_to_firmwarefile = NG
	end if
end function

sub device_store_firmware(data as string)
	dim filenum as byte
	dim filename as string
	
	if part_size = 4294836225 then exit sub
	'refresh timer when data comes
	upgrade_timer=0
	'if always on mode, store data directly to the destination file.
	'otherwise stored it to partial file and only copy to destination file if partial file is varified.
	if operation_mode = 0 then
		filenum = firmware_filenum
		filename = FIRMWARE_FILE
		part_checksum = firmware_checksum
	else
		filenum = part_filenum
		filename = PART_FILE
	end if
	
	fd.filenum=filenum
	if fd.fileopened=NO then
		fd.open(filename)
	end if
	
	fd.setdata(data)
	
	if fd.filesize = part_size then

		dim checksum as dword=0
		fd.setpointer(1)		
		do
			data=fd.getdata(255)
			checksum=checksum+(strsum(data))
		loop while fd.pointer <= fd.filesize
		
	'checksum verify
		if checksum <> part_checksum then
			if operation_mode = 0 then
				device_add_event("Upgrade failed, retry..")
			else
				device_add_event("Upgrade failed, retry..")
				device_upgrade_start()				
			end if
			exit sub
		end if	
	else
		exit sub
	end if
	
	'checksum verification passed
	if operation_mode = 0 then
		stg_set("UPD",0,"255")
		fd.copyfirmwarefromfilelzo()
	else
		if copy_partfile_to_firmwarefile() = OK then
			device_add_event(+str(part_num+1)+"/"+str(total_chuncks)+" downloaded")
		else	
			device_add_event("Upgrade failed, retry..")
			device_upgrade_start()			
		end if
		'in power saving mode, connect to azure to finish other task
		connect_to_azure_server()
	end if	
end sub

public sub upgrade_init()
	firmware_filenum = filenum_get("FMW")
	part_filenum = filenum_get("PAR")
	upgrade_state = val(stg_get("UPD",0))
	upgrade_trigger = val(stg_get("UPGS",0))
	
	fd.filenum=part_filenum
	fd.delete(PART_FILE)
	fd.create(PART_FILE)

	if upgrade_state = 0 or operation_mode = 0 then
		fd.filenum=firmware_filenum
		fd.delete(FIRMWARE_FILE)
		fd.create(FIRMWARE_FILE)		
	end if
	
	if upgrade_state = 254 then
		stg_set("UPD",0,"255")
		fd.filenum = firmware_filenum
		if fd.open(FIRMWARE_FILE) = PL_FD_STATUS_OK then
			fd.copyfirmwarefromfilelzo()
		end if
	end if
	
end sub

public sub connect_to_firmware_server()
	dim url as string
	
	mqtt_disconnect()
	http_stop()
	dns_disconnect()
	if sock.tlscurrentnum<>255 then
		sock.num=sock.tlscurrentnum
		sock.tlsdeinit()	
		if sock.statesimple = PL_SSTS_EST then
			sock.discard()
		end if
	end if	
	url=stg_get("DLPT",0)
	http_request(HTTP_GET, url, current_interface,"")		
end sub

public sub connect_to_azure_server()		
	dim AZURE_DEVICE_ID as string=stg_get("DVID",0)
	dim AZURE_SCOPE_ID as string=stg_get("SCID",0)
	dim AZURE_DPS_SERVER as string=stg_get("DPSS",0)
	dim AZURE_PRIMARY_KEY as string=stg_get("PKEY",0)
	
	'when switching between server making sure all previous connection is closed
	http_stop()
	dns_disconnect()
	 
	if sock.tlscurrentnum<>255 then
		sock.num=sock.tlscurrentnum
		sock.tlsdeinit()	
		if sock.statesimple = PL_SSTS_EST then
			sock.discard()
		end if
	end if
	upgrade_state=255
	azure_start(AZURE_DEVICE_ID,AZURE_SCOPE_ID,AZURE_DPS_SERVER,AZURE_PRIMARY_KEY,current_interface)
end sub

' This function is to read the sensor board that has a local MCU on it and T/H and CO2 sensor is populated on it
sub read_onboard_t_h_co2_sensor()
	dim data0, data1, data2, data3, data4, data5, data6, data7 as byte
	dim tmp1,hi,lo,temp2 as byte
	dim co2, humidity, temperature as float
	dim humd,temp,str_co2,error,ts as string(36)
	dim daycounts, mincounts as word
	dim seconds as byte
	
	sensor_channel = si2c_register("SNR", SENSOR_DAT_PIN, SENSOR_CLK_PIN, NO)
	si2c_get(sensor_channel)
	
	'fetch temperature and humidity data

	si2c_start()
	si2c_write(SENSOR_ADDR OR PIC_WR)
	si2c_write(&h80)

	delay_ms(5)
	
	si2c_start()
	si2c_write(SENSOR_ADDR OR PIC_RD)
	data0=si2c_read(true)
	data1=si2c_read(true)
	data2=si2c_read(true)
	data3=si2c_read(true)
	data4=si2c_read(false)
	si2c_stop()
	
	'fetch CO2 data

	si2c_start()
	si2c_write(SENSOR_ADDR OR PIC_WR)
	si2c_write(&h90)

	delay_ms(5)
	
	si2c_start()
	si2c_write(SENSOR_ADDR OR PIC_RD)
	data5=si2c_read(true)
	data6=si2c_read(true)
	data7=si2c_read(false)
	
	si2c_stop()

' Calculation
	tmp1=data1*4
	humidity=tmp1*64+data2

	tmp1=data3*4
	tmp1=tmp1/16
	hi=data3/64*16
	hi=hi+tmp1

	tmp1=data3 and &h03
	tmp1=tmp1*64

	temp2=data4 and &hC0
	temp2=temp2/4
	lo=tmp1+temp2

	tmp1=data4 and &h3C
	tmp1=tmp1/4
	lo=lo+tmp1

	temperature=hi*256+lo
	humidity=(humidity*100)/16383

	temperature=temperature/16383
	temperature=temperature*165
	
	co2=data5
	co2=co2*256+data6
	humd=ftostr(humidity,FTOSTR_MODE_AUTO,5)
	temp=ftostr(temperature,FTOSTR_MODE_AUTO,5)
	str_co2=ftostr(co2,FTOSTR_MODE_AUTO,5)
	
	error=hex(data7)
	error=right(error,len(error)-2)

	'check the timestampe, if it's invalid, don't sample, but sample again in 2 sec
	rtc.getdata(daycounts,mincounts,seconds)
	if daycounts>0 then
		time_to_str(ts,daycounts,mincounts,seconds)
		ts=ts+".000Z"
		
		add_telemetry("temperature",temp,ts)
		add_telemetry("humidity",humd,ts)
		add_telemetry("co2",str_co2,ts)
		'in power saving mode log battery level
		if operation_mode = 1 then
			add_telemetry("BAT_LVL",str(battery_level),ts)
		end if
		
		sys.debugprint(temp+"C "+humd+"% "+str_co2+chr(10)+chr(13))
	else
		sample_timer=4
	end if	
end sub
' This function is to read the sensor board that has a local MCU on it and T/H sensor is populated on it but CO2 sensor is NOT populated on it
sub read_onboard_t_h_sensor()
	dim data0, data1, data2, data3, data4 as byte
	dim tmp1,hi,lo,temp2 as byte
	dim humidity, temperature as float
	dim humd,temp,ts as string(36)
	dim daycounts, mincounts as word
	dim seconds as byte
	
	sensor_channel = si2c_register("SNR", SENSOR_DAT_PIN, SENSOR_CLK_PIN, NO)
	si2c_get(sensor_channel)
	
	'fetch temperature and humidity data

	si2c_start()
	si2c_write(SENSOR_ADDR OR PIC_WR)
	si2c_write(&h80)

	delay_ms(5)
	
	si2c_start()
	si2c_write(SENSOR_ADDR OR PIC_RD)
	data0=si2c_read(true)
	data1=si2c_read(true)
	data2=si2c_read(true)
	data3=si2c_read(true)
	data4=si2c_read(false)
	si2c_stop()
	
' Calculation
	tmp1=data1*4
	humidity=tmp1*64+data2

	tmp1=data3*4
	tmp1=tmp1/16
	hi=data3/64*16
	hi=hi+tmp1

	tmp1=data3 and &h03
	tmp1=tmp1*64

	temp2=data4 and &hC0
	temp2=temp2/4
	lo=tmp1+temp2

	tmp1=data4 and &h3C
	tmp1=tmp1/4
	lo=lo+tmp1

	temperature=hi*256+lo
	humidity=(humidity*100)/16383

	temperature=temperature/16383
	temperature=temperature*165
	'temperature=temperature-40
	
	humd=ftostr(humidity,FTOSTR_MODE_AUTO,5)
	temp=ftostr(temperature,FTOSTR_MODE_AUTO,5)
	
	'check the timestampe, if it's invalid, don't sample, but sample again in 2 sec
	rtc.getdata(daycounts,mincounts,seconds)
	if daycounts>0 then
		time_to_str(ts,daycounts,mincounts,seconds)
		ts=ts+".000Z"
		
		add_telemetry("temperature",temp,ts)
		add_telemetry("humidity",humd,ts)
		'in power saving mode log battery level
		if operation_mode = 1 then
			add_telemetry("BAT_LVL",str(battery_level),ts)
		end if
		sys.debugprint(temp+"C "+humd+"% "+chr(10)+chr(13))
	else
		sample_timer=4
	end if	
end sub

sub read_modbus_bp02()
	dim daycounts, mincounts as word
	dim seconds as byte
	
	rtc.getdata(daycounts,mincounts,seconds)
	time_to_str(sensor_telemetry_ts,daycounts,mincounts,seconds)
	sensor_telemetry_ts=sensor_telemetry_ts+".000Z"
	modbus_master_request(modbus_device_id, ReadInputRegisters, 400, 1, "", MODBUS_UART, modbus_RTU) 'temperature
	modbus_master_request(modbus_device_id, ReadInputRegisters, 404, 1, "", MODBUS_UART, modbus_RTU) 'humidity

end sub


' This function is to only read the onboard sensor directly connected to the ACSIP without an MCU/PIC in the middle
' This type of sensor board and thus this function is going to be depreciated soon.
sub read_onboard_hum_temp_legacy()
	dim data1, data2, data3, data4 as byte
	dim tmp1,hi,lo,temp2 as byte
	dim humidity, temperature as float
	dim daycounts, mincounts as word
	dim seconds as byte
	dim ts, humd, temp as string(36)
	
	sensor_channel = si2c_register("SNR", SENSOR_DAT_PIN, SENSOR_CLK_PIN, NO)
	si2c_get(sensor_channel)
	
	si2c_start()
	si2c_write(HIH6130_WRITE_ADDR)
	si2c_stop()

	delay_ms(50)

	'fetch humidity data
	si2c_start()
	si2c_write(HIH6130_READ_ADDR)
	data1=si2c_read(true)
	data2=si2c_read(true)
	data3=si2c_read(true)
	data4=si2c_read(false)
	si2c_stop()

	'humidity:   Data1 [13:6] + Data2 [7:0]
	'temerature: Data3 [13:6] + Data4 [5:0]
	tmp1=data1*4
	humidity=tmp1*64+data2

	tmp1=data3*4
	tmp1=tmp1/16
	hi=data3/64*16
	hi=hi+tmp1

	tmp1=data3 and &h03
	tmp1=tmp1*64

	temp2=data4 and &hC0
	temp2=temp2/4
	lo=tmp1+temp2

	tmp1=data4 and &h3C
	tmp1=tmp1/4
	lo=lo+tmp1

	temperature=hi*256+lo
	humidity=(humidity*100)/16383

	temperature=temperature/16383
	temperature=temperature*165
	temperature=temperature-40
	
	humd=ftostr(humidity,FTOSTR_MODE_AUTO,5)
	temp=ftostr(temperature,FTOSTR_MODE_AUTO,5)
	
	'check the timestampe, if it's invalid, don't sample, but sample again in 2 sec
	rtc.getdata(daycounts,mincounts,seconds)
	if daycounts>0 then
		time_to_str(ts,daycounts,mincounts,seconds)
		ts=ts+".000Z"

		add_telemetry("temperature",temp,ts)
		add_telemetry("humidity",humd,ts)
		'in power saving mode log battery level
		if operation_mode = 1 then
			add_telemetry("BAT_LVL",str(battery_level),ts)
		end if
		sys.debugprint(temp+"C "+humd+"% "+chr(10)+chr(13))
	else
		sample_timer=4
	end if
end sub

sub pic_write(addr as byte, byref data as string)
	dim i as byte
	
	si2c_get(pic_channel)
	si2c_start()
	si2c_write(PIC_ADDR OR PIC_WR)
	si2c_write(addr)
	for i = 1 to len(data)
		delay_ms(10)
		si2c_write(asc(mid(data,i,1)))
	next i
	delay_ms(10)
	si2c_stop()
end sub

function pic_read(addr as byte, length as byte) as string
	dim i as byte
	
	pic_read=""
	si2c_get(pic_channel)
	si2c_start()
	si2c_write(PIC_ADDR OR PIC_WR)	
	si2c_write(addr)		'Set reg num
	si2c_start()
	si2c_write(PIC_ADDR OR PIC_RD)
	for i = 1 to length-1
		delay_ms(10)
		pic_read = pic_read + chr(si2c_read(true))
	next i
	delay_ms(10)
	pic_read = pic_read + chr(si2c_read(false))
	delay_ms(10)
	si2c_stop()
end function

function add_telemetry(byref telemetry_name as string, byref telemetry_value as string, byref ts as string) as en_tbl_status_codes
	
	add_telemetry=tbl_select("Azure","Azure")
	if add_telemetry<>EN_TBL_STATUS_OK then exit function
	add_telemetry=tbl_field_sg("time",ts,EN_TBL_SET)
	if add_telemetry<>EN_TBL_STATUS_OK then exit function
	add_telemetry=tbl_field_sg("type",telemetry_name,EN_TBL_SET)
	if add_telemetry<>EN_TBL_STATUS_OK then exit function	
	add_telemetry=tbl_field_sg("value",telemetry_value,EN_TBL_SET)
	if add_telemetry<>EN_TBL_STATUS_OK then exit function	
	add_telemetry=tbl_record_add("")	
end function

function need_to_connect() as no_yes
	dim active_rec_num as word
	dim number_of_fld as byte
	dim daycounts, mincounts as word
	dim seconds as byte
	
	need_to_connect = NO
	
	rtc.getdata(daycounts,mincounts,seconds)
	if operation_mode = 0 or daycounts = 0 then
		need_to_connect=YES
		exit function
	end if
	
	select case sensor_type
	case 0,1: 
		number_of_fld = 2
		'in power saving mode log battery level
		if operation_mode = 1 then number_of_fld = number_of_fld+1
	case 2: 
		number_of_fld = 3
		'in power saving mode log battery level
		if operation_mode = 1 then number_of_fld = number_of_fld+1
	case 128:
		number_of_fld = 2
	case else:	
	end select
	
    tbl_select("Azure","Azure")
	tbl_get_num_records(active_rec_num,NO)
	active_rec_num=active_rec_num/number_of_fld
	min_rec_num_to_send=val(stg_get("RCN",0))
	if active_rec_num >= min_rec_num_to_send-1 then
		need_to_connect = YES
	end if
end function

sub update_stg_ts_and_send_azure(byref stg_name as string)
	dim stg_val as string
	
	'use stg_timestamp.ts_milsec as a flag to detect if the setting has been changed
	'push to server if it is 0, and set it to 999 after push
	stg_val=stg_get(stg_name,0)
	if stg_timestamp.ts_milsec = 0 then
		azure_send_property(stg_name, stg_val)
		stg_timestamp.ts_milsec = 999
		stg_set_ts(stg_name)
	end if	
end sub

function modbus_callback_ReadCoilStatus(address as word) as boolean
	
end function

function modbus_callback_ReadInputStatus(address as word) as boolean
	
end function

function modbus_callback_WriteSingleCoil(address as word, value as low_high) as boolean
	
end function

function modbus_callback_ReadHoldingRegister(address as word) as word
	
end function

function modbus_callback_ReadInputRegister(address as word) as word
	
end function

function modbus_set_holding_register(address as word, data as string) as boolean
	
end function

sub callback_modubus_timeout(device_id as byte)
	sample_timer = 4
end sub

sub callback_modbus_slave_reply(byref request_item as modbus_request_item, byref reply as string)
	dim bytes as byte(255) = reply
	dim light, temp as string(36)
	dim tbl_result as en_tbl_status_codes	
	
	if request_item.device_id = modbus_device_id then
		if request_item.start_register=400 then
			dim BP_02_Temperature_val as word = modbus_read_word(bytes,0)
			temp=str(BP_02_Temperature_val)
			temp=left(temp,len(temp)-1)+"."+right(temp,1)
			sys.debugprint(temp+" C\n")
			tbl_result=tbl_select("Azure","Azure")
			tbl_result=tbl_field_sg("time",sensor_telemetry_ts,EN_TBL_SET)
			tbl_result=tbl_field_sg("type","temperature",EN_TBL_SET)
			tbl_result=tbl_field_sg("value",temp,EN_TBL_SET)				
			tbl_result=tbl_record_add("")	
		end if
		
		if request_item.start_register=404 then
			dim BP_02_Humidity_val as word = modbus_read_word(bytes,0)
			temp=str(BP_02_Humidity_val)
			temp=left(temp,len(temp)-1)+"."+right(temp,1)
			sys.debugprint(temp+" RH\n")
			tbl_result=tbl_select("Azure","Azure")
			tbl_result=tbl_field_sg("time",sensor_telemetry_ts,EN_TBL_SET)
			tbl_result=tbl_field_sg("type","humidity",EN_TBL_SET)
			tbl_result=tbl_field_sg("value",temp,EN_TBL_SET)				
			tbl_result=tbl_record_add("")	
		end if
	end if
end sub

sub update_server_properties()

	if property_modified = YES then
		update_stg_ts_and_send_azure("FWV")
		update_stg_ts_and_send_azure("DLPT")
		update_stg_ts_and_send_azure("TZ")
		update_stg_ts_and_send_azure("DVNT")
		update_stg_ts_and_send_azure("CID")
		property_modified = NO
	end if
end sub

public function turn_sensor3v3_on() as boolean
	pic_write(&hA0,"\x77")
	delay_ms(5)
	if (pic_read(&hA0,1)="\x77") then
		turn_sensor3v3_on=true
	else
		turn_sensor3v3_on=false
	end if
end function

public function turn_sensor3v3_off() as boolean
	pic_write(&hA0,"\x00")
	delay_ms(5)
	if (pic_read(&hA0,1)="\x00") then
		turn_sensor3v3_off=true
	else
		turn_sensor3v3_off=false
	end if
end function

